<html><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8"><title>Эффективная многопоточность</title><meta name="description" content="Статья посвящена системным механизмам, организующим (или помогающим организовать) пул потоков. Рассматриваются базовые, универсальные сервисы, с помощью которых можно реализовывать серверы для любых доступных механизмов взаимодействия сервера и клиента: сокеты, именованные каналы (named pipes), почтовые ящики (mailslots) и проч."><meta name="keywords" content="thread pool"><meta name="robots" content="index,follow"><link rel="stylesheet" href="%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_files/article.css" type="text/css"><script async="" src="%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_files/analytics.js"></script><script type="text/javascript" src="%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_files/jquery.js"></script><script type="text/javascript" src="%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_files/rsdn.js"></script><script type="text/javascript" src="%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_files/Forum.js" charset="utf-8"></script><link rel="canonical" href=""></head><body marginwidth="20" marginheight="20"><table celpadding="2" style="font-family:verdana;font-weight:bold;padding: 0px 5px; BORDER: #9daabd 1px 	solid; 	COLOR: #646464; BACKGROUND-COLOR: #e6e6e6;" width="100%" cellspacing="0" border="0"><tbody><tr><td nowrap="nowrap"><font style="font-weight:normal" size="1"><script src="%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_files/shMenu.js" type="text/javascript" charset="utf-8"></script>&lt;&lt;<a href="https://www.rsdn.org/?article/baseserv/threadpool.xml" target="_top">Показать&nbsp;меню</a>&nbsp;</font></td><td width="100%" nowrap="nowrap" align="right"><font size="2">&nbsp;<a href="https://www.rsdn.org/article/baseserv/threadpool.xml?print" target="_blank" title="Версия для печати"><img src="%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_files/printer2.gif" width="16" height="14" border="0" align="absmiddle"></a>&nbsp;&nbsp;<a href="https://www.rsdn.org/forum/winapi/350009" target="_self" title="Перейти к обсуждению статьи"><font size="1" color="#646464"> Сообщений </font><font color="black">4</font></a>&nbsp;&nbsp;<a href="https://www.rsdn.org/forum/winapi/350009" target="_self" title="Перейти к обсуждению статьи"><img src="%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_files/showfr.gif" width="18px" height="14px" border="0" align="absmiddle"></a>&nbsp;<a href="https://www.rsdn.org/Forum/RateList.aspx?mid=350009"><font color="#646464"><font size="1"> Оценка </font><font color="black">1071</font>
									[<font style="font-weight: normal;"><span style="color:green;">+1</span>/<span style="color:blue;">-0</span></font>]
								</font></a>&nbsp;&nbsp; <a target="_blank" rel="nofollow" href="https://www.rsdn.org/Users/Private/AddFav.aspx?mid=350009" onclick="return AddFav(this.href);" title="Добавить в избранное"><img src="%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_files/fav.gif" height="14px" border="0" align="absmiddle"></a>&nbsp;&nbsp;<a href="https://www.rsdn.org/Forum/Private/Subscr.aspx?tid=350009" onclick="return SubMsg(this.href)" title="Подписка на сообщения" rel="nofollow"><img class="i" src="%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_files/sub.gif" width="18px" height="14px" border="0" align="absmiddle"></a>&nbsp;&nbsp;&nbsp;<font size="1">Оценить </font><a target="_blank" rel="nofollow" href="https://www.rsdn.org/forum/Private/Rate.aspx?mid=350009&amp;rate=-3" onclick="return RateMsg(this.href);" title="+1"><img src="%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_files/n11.gif" width="18px" height="14px" border="0" align="absmiddle"></a><a target="_blank" rel="nofollow" href="https://www.rsdn.org/forum/Private/Rate.aspx?mid=350009&amp;rate=1" onclick="return RateMsg(this.href);" title="Интересно"><img src="%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_files/n1.gif" width="18px" height="14px" border="0" align="absmiddle"></a><a target="_blank" rel="nofollow" href="https://www.rsdn.org/forum/Private/Rate.aspx?mid=350009&amp;rate=2" onclick="return RateMsg(this.href);" title="Спасибо"><img src="%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_files/n2.gif" width="18px" height="14px" border="0" align="absmiddle"></a><a target="_blank" rel="nofollow" href="https://www.rsdn.org/forum/Private/Rate.aspx?mid=350009&amp;rate=3" onclick="return RateMsg(this.href);" title="Супер"><img src="%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_files/n3.gif" width="18px" height="14px" border="0" align="absmiddle"></a><a target="_blank" rel="nofollow" href="https://www.rsdn.org/forum/Private/Rate.aspx?mid=350009&amp;rate=-1" onclick="return RateMsg(this.href);" title="Удалить оценку"><img src="%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_files/nx.gif" width="18px" height="14px" border="0" align="absmiddle"></a><a target="_blank" rel="nofollow" href="https://www.rsdn.org/forum/Private/Rate.aspx?mid=350009&amp;rate=-4" onclick="return RateMsg(this.href);" title="Согласен"><img src="%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_files/np.gif" width="18px" height="14px" border="0" align="absmiddle"></a><a target="_blank" rel="nofollow" href="https://www.rsdn.org/forum/Private/Rate.aspx?mid=350009&amp;rate=0" onclick="return RateMsg(this.href);" title="Не согласен"><img src="%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_files/nm.gif" eight="14px" width="18px" border="0" align="absmiddle"></a>&nbsp;
					</font></td></tr></tbody></table><script type="text/javascript" src="%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_files/orphus.js"></script><a href="https://orphus.ru/" id="orphus" title="Система Orphus"><img alt="Система Orphus" src="%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_files/orphus.gif" width="100" height="25" border="0"></a><h1>Эффективная многопоточность</h1><h2 style="text-align: center">Организация пула потоков</h2><h5><span class="title">Автор: </span><span class="value"><a target="_blank" href="http://www.rsdn.ru/?Users/Profile.aspx?uid=3658">Алексей Ширшов</a><br>The RSDN Group</span><br><span class="title">Источник: </span><span class="value"><a target="_blank" href="http://www.rsdn.ru/mag/main.htm">RSDN Magazine #2-2003</a></span></h5><h6><span class="title">Опубликовано: </span><span class="value">03.08.2003</span><br><span class="title">Исправлено: </span><span class="value">15.04.2009</span><br><span class="title">Версия текста: </span><span class="value">1.0</span></h6><table width="98%"><tbody><tr><td class="contents" valign="top"><a href="#EAB"><b>Введение</b></a><br><div style="margin-left:2em"><a href="#EFB">Зачем это нужно</a><br></div><a href="#EAD"><b>Примитивы операционной системы</b></a><br><div style="margin-left:2em"><a href="#END">APC пользовательского режима</a><br><a href="#E4F">SetWaitableTimer</a><br><a href="#ENG">Порт завершения ввода/вывода</a><br><a href="#ENFAC">Организуем пул</a><br></div><a href="#EFJAC"><b>Встроенная поддержка пула потоков</b></a><br><div style="margin-left:2em"><a href="#EWJAC">Помещение запроса в очередь</a><br><a href="#EUMAC">Вызов функции при окончании асинхронной операции ввода/вывода</a><br><a href="#ELOAC">Периодический вызов функции</a><br><a href="#EWCAE">Вызов функции при переходе объекта в сигнальное состояние</a><br></div><a href="#ESEAE"><b>Заключение</b></a><br><a href="#EYEAE"><b>Литература</b></a><br></td><td class="contents" valign="top" align="center"><img src="%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_files/mag0203.jpg"></td></tr></tbody></table><script language="javascript">
			function ToggleCode(id)
			{
				el=document.getElementById(id);
				img=document.getElementById("img"+id);
				if(el.style.display=="none")
				{
					img.src="/images/ls2.gif";
					el.style.display="";
				}
				else
				{
					img.src="/images/ls1.gif";
					el.style.display="none";
				}
				return false;
			}
		</script><h2>Введение<a name="EAB"></a></h2>
<p>Итак, снова многопоточность. Вы скажете, какая избитая тема, уж 
сколько можно про это писать! Да, написано про нее немало. Практически 
каждый программист, который с нею сталкивался (то есть хоть раз в жизни 
вызвал функцию CreateThread), может заявить, что он про нее знает все 
или почти все. Но это глубокое заблуждение. Создание эффективных 
многопоточных серверов (а делать многопоточного клиента особого смысла 
нет) – дело сложное и требующее хороших знаний системных механизмов: 
многопоточности, синхронизации, асинхронного ввода/вывода и много 
другого. В этой статье я коснусь темы организации пула потоков для 
эффективной обработки клиентских запросов.</p>
<h3>Зачем это нужно<a name="EFB"></a></h3>
<p>Зачем организовывать пул потоков? Вопрос очень широко распространен, и
 на него давно существует ответ. Для тех, кто этот ответ знает, данный 
раздел не будет чем-то новым, так что можете его пропускать.</p>
<p>При приходе клиентского запроса у сервера имеется несколько вариантов действий:</p>
<ul style="LIST-STYLE:square"><li>Обрабатывать все запросы в одном потоке; </li>
<li>Обрабатывать каждый запрос в отдельном потоке; </li>
<li>Организовать пул потоков. </li>
</ul>
<p>Рассмотрим каждый из сценариев.</p>
<h4>Обработка всех запросов в одном потоке</h4>
<p>Сразу понятно, что это решение подходит только для очень 
ограниченного числа случаев, в которых количество клиентов невелико, и 
обращаются они к серверу не часто. Эта самая простая схема работы: 
минимум потоков, минимум ресурсов, и не нужно ничего синхронизировать. 
Главное, что нужно сделать – построить очередь входящих запросов, чтобы 
они не терялись при последовательной обработке. Это несложно, к тому же 
можно взять уже готовые решения: например, СОМ-сервер STA singleton.</p>

<h4>Обработка каждого запроса в отдельном потоке</h4>
<p>Это, пожалуй, самая популярная у разработчиков схема. В ней для 
каждого клиентского запроса создается отдельный поток. Решение это 
простое и для многих случаев удовлетворительное, так как при этом нужно 
заботиться, по большому счету, только о синхронизации общих переменных 
потоков (а их может и не быть). Такая схема работает следующим образом: 
первичный поток приложения прослушивает клиентские запросы и при 
поступлении каждого создает новый поток, передавая ему клиентский пакет 
(данные или команду). Созданный поток выполняет соответствующую 
обработку, передает результаты обратно клиенту, или же помещает их в БД 
(или еще куда-нибудь), и завершает свое существование.</p>
<p>Давайте задумаемся, что произойдет, если клиентов окажется слишком 
много. Сервер для каждого из них будет создавать поток, а это, с точки 
зрения системы, непростая операция, требующая определенного времени и 
ресурсов. Виртуальное адресное пространство процесса также уменьшается 
как минимум на принятый по умолчанию для потока размер стека. Все это 
очень плохо. Сервер тратит время и ресурсы на создание потока, который 
обрабатывает клиентский запрос всего за доли секунды и затем 
уничтожается. При этом мы должны учитывать, что физически одновременно 
выполняться могут только количество потоков, не превышающее числа 
процессоров на компьютере. На ОС Windows NT/2000 при 100 одновременно 
запущенных потоках наш сервер будет работать очень неоптимально, что 
отрицательно скажется на времени обработки запроса.</p>
<p>Основные недостатки такой модели:</p>
<ul style="LIST-STYLE:square"><li>частое создание и завершение потоков; </li>
<li>малое время работы потока; </li>
<li>нерегулируемое количество потоков; </li>
<li>в большинстве случаев отсутствие очереди клиентских запросов; </li>
<li>большое количество переключений контекстов рабочих потоков. </li>
</ul>
<p>Для решения этих проблем и предназначен пул потоков.</p>

<h4>Организация пула потоков</h4>
<p>Что такое пул потоков? В жизни мы очень часто встречаемся с 
организацией пула. Например, когда вы идете в столовую, вы встречаетесь с
 пулом подносов. Да-да, не смейтесь. Подносы организованы в пул 
(попробуйте объяснить это поварам :) ); клиентов может быть намного 
меньше, чем подносов, и наоборот. Когда подносов много, они лежат без 
дела, когда подносов мало, клиенты ждут, пока они освободятся. Число 
подносов, то есть размер пула, заранее определяется так, чтобы в 
большинстве случаев клиенты не ждали подносов. Однако случаются часы 
пик, когда клиентов очень много. Просто нереально выделить отдельный 
поднос каждому клиенту, да и не нужно это. Клиент все равно будет стоять
 в очереди к кассе, так что траты на подносы не принесут реальных выгод.
 Это, конечно, очень далекая и несовершенная аналогия, но она 
показывает, что в природе и жизни пул чего-либо очень часто используется
 как наиэффективнейшая схема обслуживания запросов.</p>
<p>Рассмотрим механизм работы пула потоков. Имеется главный поток 
приложения, прослушивающий клиентские запросы. Пул потоков создается 
заранее или при поступлении первого запроса. Минимальный размер пула 
обычно выбирается равным 1, однако это непринципиально. При поступлении 
запроса главный поток выбирает поток из пула и передает ему запрос. Если
 количество потоков в пуле достигло максимума, запрос помещается в 
очередь. Если количество потоков меньше максимального, и все они заняты 
обработкой, создается новый поток, который получает клиентский пакет на 
обработку. Если количество потоков равно максимальному и все потоки 
занимаются обработкой, то есть активны, пакет ставится в очередь и ждет 
освобождения одного из потоков. Алгоритмы добавления потоков в пул и 
определения оптимального размера пула сильно зависят от решаемой задачи.
 Более подробно об этом будет сказано позже.</p>
<p>При использовании RPC-транспорта (в случае с СОМ-серверами) о пуле 
потоков заботиться не нужно. СОМ-сервер MTA singleton – лучшее решение 
для СОМ в том смысле, что ничего не нужно делать по поводу организации 
пула потоков. Система (точнее СОМ-runtime) все делает сама. Однако, если
 вы используете чистый RPC, вам придется все организовывать самому.</p>


<h2>Примитивы операционной системы<a name="EAD"></a></h2>
<p>Сразу оговорюсь, что в качестве операционной системы я буду 
рассматривать Windows NT версии 3.1 и выше. Для функций, которые 
появились позже, версия ОС будет оговариваться отдельно. Линейка Windows
 9x не предоставляет никаких средств для организации пула потоков.</p>
<p>В операционной системе есть три механизма организации очереди 
запросов (очередь запросов – неотъемлемая часть пула): DPC – deferred 
procedure call (отложенный вызов процедуры), APC – asynchronous 
procedure call (асинхронный вызов процедуры) и объект ядра queue 
(очередь), которая доступна приложениям пользовательского режима (user 
mode) в виде более сложного объекта "порт завершения ввода/вывода". DPC 
используется только в режиме ядра (kernel mode) в основном драйверами 
устройств для более эффективной обработки запросов ввода/вывода. DPC мы 
рассматривать не будем, так как эта тема больше касается 
программирования драйверов устройств, а мы собираемся писать прикладную 
программу пользовательского режима. APC, в отличии от DPC, всегда 
выполняется в контексте какого-либо потока (с каждым потоком 
ассоциирована своя очередь APC-запросов) и может генерировать страничные
 ошибки (page faults), ожидать перехода объекта ядра в сигнальное 
состояние, и так далее.</p>
<table class="note" width="98%"><tbody><tr><td><strong>ПРИМЕЧАНИЕ</strong><br><p>А
 почему функции DPC не могут генерировать страничные ошибки? Дело в том,
 что DPC и APC ставятся в очередь системой с помощью программного 
прерывания и обрабатываются на определенном уровне прерываний IRQL – 
interrupt request level. IRQL DPC совпадает с IRQL dispatch, на котором 
обрабатываются страничные ошибки (он даже называется DPC/dispatch, чтобы
 отразить это). Как только система поднимает текущий уровень до 
DPC/dispatch, все прерывания с меньшим или равным уровнем маскируются 
(блокируются). После обработки DPC система понижает уровень и, если в 
очереди находиться еще один DPC-запрос, вновь генерируется программное 
прерывание. Если при обработке DPC-запроса случится обращение к странице
 памяти, не находящейся в физической памяти, система не сможет 
«подкачать» эту страницу с диска. Уровень прерывания IRQL APC ниже 
DPC/dispatch, так что APC могут свободно наслаждаться всеми прелестями 
виртуального адресного пространства процесса.</p>
</td></tr></tbody></table>
<p>APC бывают двух видов: режима ядра и пользовательского режима. APC 
режима ядра отличается от APC пользовательского режима тем, что система 
может прервать работу потока для вызова процедуры без его ведома, тогда 
как для исполнения APC пользовательского режима поток должен находится в
 специальном «тревожном» (alertable) ожидании, как бы давая согласие на 
исполнение процедуры. Объект "очередь" и его производный объект "порт 
завершения ввода/вывода" специально предназначены для организации пула 
и, кроме очереди запросов, могут управлять ассоциированными с ними 
потоками. Давайте рассмотрим APC пользовательского режима и порт 
завершения ввода/вывода более подробно.</p>
<h3>APC пользовательского режима<a name="END"></a></h3>
<p>Этот механизм можно использовать, если нужно выполнить какую-либо 
операцию (функцию) в контексте определенного потока. Для выполнения 
функции поток должен «дать согласие», перейдя в состояние тревожного 
ожидания (alertable wait state). Если поток находится в таком состоянии,
 то, как только мы поставим в очередь APC-запрос с указанием адреса 
функции и произвольного параметра для нее, поток перейдет к выполнению 
данной функции, после чего выйдет из состояния ожидания. APC 
пользовательского режима могут использовать функции ReadFileEx, 
WriteFileEx, а также SetWaitableTimer, о которой мы поговорим отдельно. 
Функции ReadFileEx и WriteFileEx предназначены специально для 
асинхронных операций – для них вы обязаны открывать файл (файл в самом 
общем смысле) в асинхронном режиме, указывая флаг FILE_FLAG_OVERLAPPED, а
 также для каждой операции создавать структуру OVERLAPPED. В качестве 
последнего параметра обе функции принимают адрес специальной функции 
завершения – FileIOCompletionRoutine. После завершения асинхронной 
операции, если поток находится в тревожном ожидании, эта функция будет 
вызвана с помощью механизма APC. В тревожное ожидание поток может 
перейти с помощью «расширенных» функций ожидания, которые оканчиваются 
на Ex. Это SleepEx, WaitForSingleObjectEx, WaitForMultipleObjectsEx и 
другие. Для того чтобы вручную поместить APC-запрос в очередь потока, 
нужно воспользоваться функцией QueueUserAPC. Вот ее прототип:</p>
<div id="ESD"><table class="code" width="98%"><tbody><tr><td><pre>DWORD QueueUserAPC(
  PAPCFUNC pfnAPC,  <span class="COMMENT">// APC функция</span>
  HANDLE hThread,   <span class="COMMENT">// хендл потока</span>
  ULONG_PTR dwData  <span class="COMMENT">// параметр APC функции</span>
);
</pre></td></tr></tbody></table></div>
<p>Рассмотрим небольшой пример ее использования (проверка ошибок устранена для повышения наглядности).</p>
<div id="E4D"><table class="code" width="98%"><tbody><tr><td><pre><span class="KEYWORD">const</span> <span class="KEYWORD">int</span> _SOME_MAGIC_VALUE = 5;

DWORD CALLBACK trd1(LPVOID p)
{
  HANDLE hEvent = (HANDLE)p;
  SetEvent(hEvent);

  <span class="KEYWORD">int</span> i = 0;
  <span class="KEYWORD">while</span>(i &lt; _SOME_MAGIC_VALUE){
    SleepEx(INFINITE, <span class="KEYWORD">true</span>);
    cout &lt;&lt; i++ &lt;&lt; endl;
  }
  <span class="KEYWORD">return</span> 0;
}

VOID CALLBACK APCProc(ULONG_PTR dwParam)
{
  cout &lt;&lt; <span class="STRING">"APC Proc #"</span> &lt;&lt; dwParam;
  cout &lt;&lt; <span class="STRING">" threadid :"</span> &lt;&lt; GetCurrentThreadId() &lt;&lt; endl;
}

<span class="KEYWORD">int</span> main()
{  
  HANDLE hEvent = CreateEvent(0, <span class="KEYWORD">false</span>, <span class="KEYWORD">false</span>, NULL);

  DWORD trd_id = 0;
  HANDLE hThread = CreateThread(0, 0, trd1, hEvent, 0, &amp;trd_id);
  cout &lt;&lt; <span class="STRING">"Thread id is 0x"</span> &lt;&lt; hex &lt;&lt; trd_id &lt;&lt; endl;

  WaitForSingleObject(hEvent, INFINITE);

  <span class="KEYWORD">for</span>(<span class="KEYWORD">int</span> i = 0;i &lt; _SOME_MAGIC_VALUE;i++){
    QueueUserAPC(APCProc, hThread, i);
  }

  WaitForSingleObject(hThread, 1000);
  CloseHandle(hThread);
  <span class="KEYWORD">return</span> 0;
}
</pre></td></tr></tbody></table></div>
<p>Несмотря на кажущуюся простоту, пример довольно сложен, и не всегда 
можно предсказать, что будет на экране после его завершения. Давайте 
разберем его в форме вопрос-ответ.</p>
<h4>Почему я синхронизирую потоки с помощью события?</h4>
<p>Если этого не сделать, то все пять APC-запросов выполнятся еще до 
того, как функция потока trd1 получит управление. Это произойдет потому,
 что сама система в процессе создания потока использует механизм 
APC-вызовов для инициализации потока. С его помощью, например, 
происходит вызов всех функций DllMain с параметром DLL_THREAD_ATTACH, 
если, конечно, вы не вызывали DisableThreadLibraryCalls для какой-либо 
библиотеки.</p>

<h4>Почему на экран выводится странный результат?</h4>
<div id="EJF"><table class="code" width="98%"><tbody><tr><td><pre>Thread id is 0x68c
APC Proc #0 threadid :68c
0
APC Proc #1 threadid :68c
APC Proc #2 threadid :68c
APC Proc #3 threadid :68c
APC Proc #4 threadid :68c
1
</pre></td></tr></tbody></table></div>
<p>Как я уже говорил, для каждого потока система организует очередь из 
APC-запросов, так что в момент обработки первого запроса потоком система
 успевает добавить в очередь все остальные запросы, которые и 
выполняются при следующем вызове SleepEx. Результат сильно зависит от 
загруженности системы, так что у вас он может быть другим: например, все
 запросы успеют выполниться за одну итерацию.</p>

<h4>Почему, если закомментировать тело APCProc, на экран выводится следующее?</h4>
<div id="ERF"><table class="code" width="98%"><tbody><tr><td><pre>Thread id is 0x7b4
0
1
2
3
4
</pre></td></tr></tbody></table></div>
<p>Так как теперь эта процедура фактически ничего не делает, система не 
успевает добавить новый запрос в очередь до завершения обработки 
предыдущего, так что каждый SleepEx обрабатывает «свой» APC-запрос.</p>
<p>Теперь вам должно быть понятно, как использовать данный механизм для 
организации пула потоков. Вот примерный сценарий для фиксированного 
количества потоков в пуле: в главном потоке приложения создаются 
несколько рабочих потоков, каждый из которых сразу переходит в состояние
 тревожного ожидания специально созданного основным потоком события. 
Когда приходит клиентский запрос, главный поток передает APC-запрос 
одному из рабочих потоков. Рабочий поток пробуждается и выполняет 
функцию, поставленную в очередь главным потоком. При этом он не покидает
 функции WaitForSingleObjectEx. То есть выполнение APC-запроса 
производится как бы внутри функции WaitForSingleObjectEx. После 
завершения выполнения запроса управление передается функции 
WaitForSingleObjectEx, которая, в свою очередь, передает управление 
основному коду потока, возвращая WAIT_IO_COMPLETION. </p>
<p>При получении управления рабочий поток должен проанализировать 
значение, возвращенное этой функцией. Если оно равно WAIT_IO_COMPLETION,
 то причиной выхода из функции WaitForSingleObjectEx было завершение 
обработки APC-запроса – поток при этом должен снова перейти в состояние 
ожидания события. Если же возвращается значение WAIT_OBJECT_0, то 
причиной выхода была установка события в сигнальное состояние главным 
потоком приложения. При этом рабочий поток должен завершиться. </p>
<p>Это очень простая схема (например, рабочие потоки вместо ожидания 
могут выполнять какую-то другую полезную работу), но она довольно 
неплохо объясняет механизм использования APC для организации пула.</p>


<h3>SetWaitableTimer<a name="E4F"></a></h3>
<p>Эта функция появилась с версии 4.0. Она позволяет активировать 
таймер, который через заданный период времени в 100-наносекундных 
интервалах или при наступлении заданного абсолютного времени переходит в
 сигнальное состояние. Кроме этого, можно указать процедуру завершения, 
которая будет вызвана с помощью APC-запроса в данном потоке. Для 
процедуры завершения можно указать дополнительный параметр. Функция 
хороша тем, что она не привязана к окнам и циклу выборки сообщений, как,
 например, SetTimer. С ее помощью можно использовать таймеры в любых 
приложениях, включая консольные и сервисы. Однако у SetWaitableTimer 
есть и некоторые недостатки:</p>
<ul style="LIST-STYLE:square"><li>функция завершения всегда вызывается в потоке, вызвавшем SetWaitableTimer; </li>
<li>поток должен быть в состоянии тревожного ожидания, чтобы обработать APC-запрос; </li>
<li>второй APC-запрос начнет обрабатываться только после окончания 
обработки предыдущего запроса, то есть запросы обрабатываются 
последовательно. </li>
</ul>
<p>Все эти проблемы решает объект "очередь таймеров", о котором речь пойдет позже.</p>

<h3>Порт завершения ввода/вывода<a name="ENG"></a></h3>
<p>Это, безусловно, один из самых мощных и сложных объектов 
исполнительной системы. Он специально предназначен для оптимизации 
обработки клиентских запросов в серверных приложениях. Он не только 
организует очередь запросов, но и эффективно управляет их обработкой.</p>
<p>Основная идея порта завершения ввода/вывода (в дальнейшем просто 
порта) состоит в том, чтобы эффективно расходовать процессорное время 
при обработке клиентских запросов. Обработка должна вестись параллельно 
несколькими потоками, но строго до определенного момента, когда число 
потоков будет равняться максимальному значению. После этого новые потоки
 перестают создаваться, а запросы ставятся в очередь к существующим 
потокам. Давайте разберемся в этом поподробнее.</p>
<h4>Как работает порт</h4>
<p>При создании порта указывается максимальное количество активных 
потоков, способных обрабатывать клиентские запросы параллельно. Так как 
количество реально работающих параллельно потоков на компьютере равно 
количеству процессоров, то указание б<i>о</i>льшего максимального 
количества активных потоков не выгодно. Почему? Дело в том, что для 
исполнения нескольких потоков на одном процессоре, системе приходится 
постоянно переключать процессор между потоками, эмулируя, таким образом,
 параллельность, однако это переключение, называемое переключением 
контекстов – довольно дорогая операция. Избежать ее можно только одним 
способом – не создавать параллельно работающие потоки в количестве 
большем, чем число процессоров. Таким образом, при создании порта, 
казалось бы, нужно указывать в качестве максимального количества 
активных потоков число процессоров в системе, но здесь есть одна 
тонкость. Допустим, у нас однопроцессорный компьютер и, соответственно, 
клиентские запросы мы обрабатываем в одном потоке. Что будет, если 
клиентский запрос придет в момент выполнения синхронной операции с 
диском или в момент ожидания какого-либо объекта этим потоком? Он будет 
ждать, пока поток не закончит свою работу, но ведь процессор в это время
 бездействует, потому что поток заблокирован на синхронной операции или 
на каком-либо объекте. Когда процессор бездействует, а клиентский запрос
 не обрабатывается – это плохо. Мы приходим к выводу о том, что всегда 
должен существовать резервный поток, который подхватывал бы запросы в 
момент, когда «основной» поток выполняет блокирующие операции, и 
процессор бездействует.</p>
<p>Работа с файлами (в самом широком смысле слова) очень тесно связана с
 многопоточностью и обработкой запросов на сервере. Сокет или pipe – это
 тоже файлы. Чтобы обрабатывать запросы через эти каналы <b>параллельно, </b>нужен
 порт. Давайте рассмотрим функцию создания порта и связи его с файлом 
(зачем-то разработчики из Microsoft объединили две эти функции в одну; в
 исполнительной системе эти две функции выполняют сервисы 
NtCreateIoCompletion и NtSetInformationFile, соответственно).</p>
<div id="EBH"><table class="code" width="98%"><tbody><tr><td><pre>HANDLE CreateIoCompletionPort (
  HANDLE FileHandle,              <span class="COMMENT">// хендл файла</span>
  HANDLE ExistingCompletionPort,  <span class="COMMENT">// хендл порта завершения ввода/вывода</span>
  ULONG_PTR CompletionKey,        <span class="COMMENT">// ключ завершения</span>
  DWORD NumberOfConcurrentThreads <span class="COMMENT">// максимальное число параллельных потоков</span>
);
</pre></td></tr></tbody></table></div>
<p>Для простого создания порта нужно в качестве первого параметра 
передать INVALID_HANDLE_VALUE, а в качестве второго и третьего – 0. Для 
связывания файла с портом нужно указать первые три параметра и 
проигнорировать четвертый.</p>
<p>После того, как файл (под файлом здесь подразумевается объект 
подсистемы Win32, который реализуется с помощью объекта "файл 
исполнительной системы", к таковым относятся файлы, сокеты, почтовые 
ящики, именованные каналы и проч.) связан с портом, окончания всех 
асинхронных запросов ввода/вывода попадают в очередь порта и могут быть 
обработаны пулом потоков. Следующие функции могут быть использованы с 
портом завершения для обработки асинхронных операций ввода/вывода:</p>
<ul style="LIST-STYLE:square"><li><b>ConnectNamedPipe</b> – ожидает подключения клиента к именованному каналу. </li>
<li><b>DeviceIoControl</b> – низкоуровневый ввод/вывод. </li>
<li><b>LockFileEx</b> – блокировка региона файла. </li>
<li><b>ReadDirectoryChangesW</b> – ожидание изменений в директории. </li>
<li><b>ReadFile</b> – чтение файла. </li>
<li><b>TransactNamedPipe</b> – Комбинированное чтение и запись по именованному каналу, осуществляемые за одну сетевую операцию. </li>
<li><b>WaitCommEvent</b> – ожидание события последовательного интерфейса (СОМ-порт). </li>
<li><b>WriteFile</b> – запись в файл. </li>
</ul>
<p>Если вы не хотите, чтобы окончание асинхронного ввода/вывода 
обрабатывалось портом (например, когда вам не важен результат операции),
 нужно использовать следующий трюк [1]. Нужно установить поле hEvent 
структуры OVERLAPPED равным описателю события с установленным первым 
битом. Делается это примерно так:</p>
<div id="EVAAC"><table class="code" width="98%"><tbody><tr><td><pre>OVERLAPPED ov = {0};
ov.hEvent = CreateEvent(...);
ov.hEvent = (HANDLE)((DWORD_PTR)(ov.hEvent) | 1);
</pre></td></tr></tbody></table></div>
<p>И не забывайте сбрасывать младший бит при закрытии хендла события.</p>
<p>Добавлять поток к пулу (подключать его к обработке запросов) можно с помощью следующей функции:</p>
<div id="E2AAC"><table class="code" width="98%"><tbody><tr><td><pre>BOOL GetQueuedCompletionStatus(
  <span class="COMMENT">// хендл порта завершения ввода/вывода</span>
  HANDLE CompletionPort, 
  <span class="COMMENT">// количество переданных байт</span>
  LPDWORD lpNumberOfBytes, 
  <span class="COMMENT">// ключ завершения</span>
  PULONG_PTR lpCompletionKey, 
  <span class="COMMENT">// структура OVERLAPPED</span>
  LPOVERLAPPED *lpOverlapped, 
  <span class="COMMENT">// значение таймаута</span>
  DWORD dwMilliseconds
);
</pre></td></tr></tbody></table></div>
<p>Эта функция блокирует поток до тех пор, пока порт не передаст потоку пакет запроса или не истечет таймаут.</p>
<p>Поместить пакет запроса в порт можно с помощью функции PostQueuedCompletionStatus.</p>
<div id="EMBAC"><table class="code" width="98%"><tbody><tr><td><pre>BOOL PostQueuedCompletionStatus(
  HANDLE CompletionPort,            <span class="COMMENT">// хендл порта завершения ввода/вывода</span>
  DWORD dwNumberOfBytesTransferred, <span class="COMMENT">// количество переданных байт</span>
  ULONG_PTR dwCompletionKey,        <span class="COMMENT">// ключ завершения</span>
  LPOVERLAPPED lpOverlapped         <span class="COMMENT">// структура OVERLAPPED</span>
);
</pre></td></tr></tbody></table></div>
<p>Пакет запроса не обязательно должен быть структурой OVERLAPPED или производной от нее [2].</p>
<p>Давайте соберем всю информацию воедино. Порт завершения – объект, 
организующий несколько очередей из клиентских запросов и потоков, их 
обрабатывающих. Поток добавляется в очередь ожидающих запрос потоков 
порта при вызове функции GetQueuedCompletionStatus. При поступлении 
запроса порт разблокирует первый поток в очереди ждущих потоков и 
передает ему этот запрос (в виде структуры OVERLAPPED и ключа 
завершения). Поток при этом перемещается в очередь активных потоков 
(число активных потоков увеличивается на 1). Предположим, у нас 
максимальное число активных потоков равно 1, тогда при поступлении 
следующего запроса другой поток из очереди ожидающих активирован не 
будет. После обработки клиентского запроса поток вновь вызывает 
GetQueuedCompletionStatus и ставится в начало списка ожидающих потоков. 
Почему поток ставится именно в начало списка? Дело в том, что потоки 
берутся из начала списка, и при низкой активности могут использоваться 
не все потоки. При этом стеки и контексты неиспользуемых потоков могут 
быть выгружены на диск за ненадобностью.</p>
<p>Если в процессе обработки запроса поток обратился к блокирующей 
функции, число активных потоков уменьшается на 1, как если бы поток 
перешел снова в очередь ожидающих потоков. Это дает возможность при 
приходе следующего клиентского запроса задействовать следующий поток из 
очереди ожидающих. Когда первый поток закончит блокирующую операцию, 
число активных потоков превысит максимальное, и при следующем вызове 
функции GetQueuedCompletionStatus один из этих потоков заблокируется, а 
второй получит пакет запроса (если он имеется).</p>
<table cellspacing="2" cellpadding="5" border="0"><tbody><tr><th>Очередь</th><th>Запись добавляется при:</th><th>Запись удаляется при:</th></tr>
<tr><th>Список устройств, ассоциированных с портом</th><td>вызове CreateIoCompletionPort</td><td>закрытии хенда файла</td></tr>
<tr><th>Очередь клиентских запросов (FIFO)</th><td>завершении асинхронной операции файла, ассоциированного с портом, или вызове функции PostQueuedCompletionStatus</td><td>передаче портом запроса потоку на обработку </td></tr>
<tr><th>Очередь ожидающих потоков</th><td>вызове функции GetQueuedCompletionStatus</td><td>начале обработки клиентского запроса потоком </td></tr>
<tr><th>Список работающих потоков</th><td>начале обработки клиентского запроса потоком </td><td>вызове потоком GetQueuedCompletionStatus или какую-либо блокирующей функции</td></tr>
<tr><th>Список приостановленных потоков</th><td>вызове потоком какой-либо блокирующей функции</td><td>выходе потока из какой-либо блокирующей функции</td></tr>
</tbody></table><font style="font-size:x-small;margin-left:1em" face="verdana"><i>Таблица 1. Список очередей порта завершения ввода/вывода [1].</i></font>

<h4>Недокументированные возможности порта и его низкоуровневое устройство</h4>
<p>Как всегда это бывает у Microsoft, порт завершения обладает многими недокументированными возможностями:</p>
<ul style="LIST-STYLE:square"><li>У порта завершения ввода/вывода может 
быть имя, и соответственно, он доступен для других процессов. Совершенно
 непонятно, почему разработчики решили скрыть эту, на мой взгляд, нужную
 особенность порта. Имя можно задать в параметре ObjectAttributes 
функции NtCreateIoCompletion. </li>
<li>Вторая особенность вытекает из первой: с портом может быть связан 
дескриптор безопасности, который также задается в параметре 
ObjectAttributes функции NtCreateIoCompletion. </li>
<li>Открывается порт с помощью функции NtOpenIoCompletion. При вызове 
функции нужно указать имя порта и уровень доступа. В качестве уровня 
доступа можно указывать все стандартные и следующие специальные права 
[2] (таблица 2). </li>
</ul>
<table cellspacing="2" cellpadding="5" border="0"><tbody><tr><th>Символическое обозначение</th><th>Константа</th><th>Описание</th></tr>
<tr><td>IO_COMPLETION_QUERY_STATE</td><td>1</td><td>Необходим для запроса состояния объекта "порт"</td></tr>
<tr><td>IO_COMPLETION_MODIFY_STATE</td><td>2</td><td>Необходим для изменения состояния объекта "порт"</td></tr>
</tbody></table><font style="font-size:x-small;margin-left:1em" face="verdana"><i>Таблица 2. </i></font>
<ul style="LIST-STYLE:square"><li>У порта можно запрашивать количество 
необработанных запросов с помощью функции NtQueryIoCompletion. Хотя в 
[3] утверждается, что эта функция определяет, находится ли порт в 
сигнальном состоянии, на самом деле она возвращает количество клиентских
 запросов в очереди. Это довольно важная информация, которую почему-то 
опять решили от нас скрыть. </li>
</ul>
<p>Давайте более детально рассмотрим, как создается и функционирует порт завершения ввода/вывода [4].</p>
<p>При создании порта функцией CreateIoCompletionPort вызывается 
внутренний сервис NtCreateIoCompletion. Объект "порт" представлен 
следующей структурой [5]:</p>
<div id="EGEAC"><table class="code" width="98%"><tbody><tr><td><pre><span class="KEYWORD">typedef</span> stuct _IO_COMPLETION
{
  KQUEUE Queue;
} IO_COMPLETION;
</pre></td></tr></tbody></table></div>
<p>То есть, по существу, объект "порт завершения" является объектом 
"очередь исполнительной системы" (KQUEUE). Вот как представлена очередь:</p>
<div id="ENEAC"><table class="code" width="98%"><tbody><tr><td><pre><span class="KEYWORD">typedef</span> stuct _KQUEUE
{
  DISPATCHER_HEADER Header;
  LIST_ENTRY EnrtyListHead;     <span class="COMMENT">//очередь пакетов</span>
  DWORD CurrentCount;
  DWORD MaximumCount;
  LIST_ENTRY ThreadListHead;   <span class="COMMENT">//очередь ожидающих потоков</span>
} KQUEUE;
</pre></td></tr></tbody></table></div>
<p>Итак, для порта выделяется память, и затем происходит его 
инициализация с помощью функции KeInitializeQueue. (все, что касается 
такого супернизкого устройства порта, взято из [4], остальное – из DDK и
 [3]).</p>
<p>Когда происходит связывание порта с объектом "файл", Win32-функция 
CreateIoCompletionPort вызывает NtSetInformationFile. Класс информации 
для этой функции устанавливается как FileCompletionInformation, а в 
качестве параметра FileInformation передается указатель на структуру 
IO_COMPLETION_CONTEXT [5] или FILE_COMPLETION_INFORMATION [3].</p>
<div id="E1EAC"><table class="code" width="98%"><tbody><tr><td><pre><span class="KEYWORD">typedef</span> <span class="KEYWORD">struct</span> _IO_COMPLETION_CONTEXT
{
  PVOID Port;
  PVOID Key;
} IO_COMPLETION_CONTEXT;

<span class="KEYWORD">typedef</span> <span class="KEYWORD">struct</span> _FILE_COMPLETION_INFORMATION 
{
  HANDLE IoCompletionHandle;
  ULONG CompletionKey;
} FILE_COMPLETION_INFORMATION, *PFILE_COMPLETION_INFORMATION;
</pre></td></tr></tbody></table></div>
<p>Указатель на эту структуру заносится в поле CompletionConext структуры FILE_OBJECT (смещение 0x6C).</p>
<p>После завершения асинхронной операции ввода/вывода для 
ассоциированного файла диспетчер ввода/вывода проверяет поле 
CompletionConext и, если оно не равно 0, создает пакет запроса (из 
структуры OVERLAPPED и ключа завершения) и помещает его в очередь с 
помощью вызова KeInsertQueue. Когда поток вызывает функцию 
GetQueuedCompletionStatus, на самом деле вызывается функция 
NtRemoveIoCompletion. NtRemoveIoCompletion проверяет параметры и 
вызывает функцию KeRemoveQueue, которая блокирует поток, если в очереди 
отсутствуют запросы, или поле CurrentCount структуры KQUEUE больше или 
равно MaximumCount. Если запросы есть, и число активных потоков меньше 
максимального, KeRemoveQueue удаляет вызвавший ее поток из очереди 
ожидающих потоков и увеличивает число активных потоков на 1. При 
занесении потока в очередь ожидающих потоков поле Queue структуры 
KTHREAD (смещение 0xE0) устанавливается равным адресу очереди (порта 
завершения). Зачем это нужно? Когда вызываются функции блокировки потока
 (WaitForSingleObject и др.), планировщик проверяет это поле, и если оно
 не равно 0, вызывает функцию KeActivateWaiterQueue, которая уменьшает 
число активных потоков порта на 1. Когда поток пробуждается после вызова
 блокирующих функций, планировщик выполняет те же действия, только 
вызывает при этом функцию KeUnwaitThread, которая увеличивает счетчик 
активных потоков на 1.</p>
<p>Когда вы помещаете запрос в порт завершения функцией 
PostQueuedCompletionStatus, на самом деле вызывается функция 
NtSetIoCompletion, которая после проверки параметров и преобразования 
хендла порта в указатель, вызывает KeInsertQueue.</p>


<h3>Организуем пул<a name="ENFAC"></a></h3>
<p>Итак, мы знаем, как работает порт завершения ввода/вывода, когда 
потоки добавляются в пул и когда удаляются. Но сколько потоков должно 
быть в пуле? В два раза больше, чем число процессоров. Это очень общая 
рекомендация, и для некоторых задач она не подходит. По большому счету 
имеется только два критерия, по которым можно определять, нужно 
создавать новый поток или нет. Эти критерии – загруженность процессора и
 число пакетов запросов. Если число пакетов превышает определенное 
количество, и загруженность процессора невысока, есть смысл создать 
новый поток. Если пакетов мало, или процессор занят более чем на 90 
процентов, дополнительный поток создавать не следует. Удалять поток из 
пула нужно, если он давно не обрабатывал клиентские запросы (просто 
подсчитать, сколько раз GetQueuedCompletionStatus вернула управление по 
таймауту). При удалении потока нужно следить, чтобы закончились все 
асинхронные операции ввода/вывода, начатые этим потоком.</p>
<p>Надо сказать, что определение загруженности процессора, количества 
пакетов в очереди порта и наличия у потока незавершенных операций 
ввода/вывода – задачи не самые простые. Например, вы можете использовать
 WMI для определения загруженности процессора, но при этом не сможете 
определить, есть ли у потока незавершенные операции ввода/вывода. Ниже я
 приведу функции получения вышеперечисленных показателей только 
недокументированными способами (здесь используется заголовочный файл 
ntdll.h из [3]): </p>
<div id="EUFAC"><table class="code" width="98%"><tbody><tr><td><pre><span class="COMMENT">// Функция получения загруженности процессора</span>
<span class="KEYWORD">double</span> GetCPUUsage()
{
  <span class="KEYWORD">#define</span> Li2Double(x) ((<span class="KEYWORD">double</span>)((x).HighPart) * 4.294967296E9 \
    + (<span class="KEYWORD">double</span>)((x).LowPart))
  
  <span class="KEYWORD">typedef</span> NTSTATUS (NTAPI ZwQuerySystemInformation_t)(
    IN NT::SYSTEM_INFORMATION_CLASS SystemInformationClass, 
    OUT PVOID SystemInformation, 
    IN ULONG SystemInformationLength, 
    OUT PULONG ReturnLength OPTIONAL
  );

  <span class="KEYWORD">static</span> ZwQuerySystemInformation_t* ZwQuerySystemInformation = 0;
  <span class="KEYWORD">if</span>(!ZwQuerySystemInformation)
  {
    ZwQuerySystemInformation = (ZwQuerySystemInformation_t*)GetProcAddress(
      GetModuleHandle(_T(<span class="STRING">"ntdll.dll"</span>)), _T(<span class="STRING">"NtQuerySystemInformation"</span>));
  }

  <span class="KEYWORD">double</span> dbIdleTime = 0;

  <span class="KEYWORD">static</span> NT::LARGE_INTEGER liOldIdleTime = {0, 0};
  <span class="KEYWORD">static</span> NT::LARGE_INTEGER liOldSystemTime = {0, 0};

  <span class="COMMENT">// Получаем число процессоров</span>
  NT::SYSTEM_BASIC_INFORMATION sysinfo = {0};
  NT::NTSTATUS status = ZwQuerySystemInformation(NT::SystemBasicInformation, 
    &amp;sysinfo, <span class="KEYWORD">sizeof</span> sysinfo, 0);
    
  <span class="KEYWORD">if</span>(status != NO_ERROR)
        <span class="KEYWORD">return</span> -1;
    
  <span class="COMMENT">// Получаем системное время</span>
  NT::SYSTEM_TIME_OF_DAY_INFORMATION timeinfo = {0};
    status = ZwQuerySystemInformation(NT::SystemTimeOfDayInformation, 
    &amp;timeinfo, <span class="KEYWORD">sizeof</span> timeinfo, 0);
    
  <span class="KEYWORD">if</span>(status!=NO_ERROR)
        <span class="KEYWORD">return</span> -1;

  <span class="COMMENT">// Получаем время простоя</span>
  NT::SYSTEM_PERFORMANCE_INFORMATION perfinfo = {0};
    status = ZwQuerySystemInformation(NT::SystemPerformanceInformation, 
    &amp;perfinfo, <span class="KEYWORD">sizeof</span> perfinfo, 0);
    
  <span class="KEYWORD">if</span>(status != NO_ERROR)
        <span class="KEYWORD">return</span> -1;

  <span class="COMMENT">// если это первый вызов, значение вычислить нельзя</span>
  <span class="KEYWORD">if</span>(liOldIdleTime.QuadPart != 0)
  {
    <span class="COMMENT">// Время простоя</span>
    dbIdleTime = Li2Double(perfinfo.IdleTime) - Li2Double(liOldIdleTime);

    <span class="COMMENT">// Системное время</span>
    <span class="KEYWORD">const</span> <span class="KEYWORD">double</span> dbSystemTime = Li2Double(timeinfo.CurrentTime) 
      - Li2Double(liOldSystemTime);

    dbIdleTime = dbIdleTime / dbSystemTime;

    dbIdleTime = 100.0 - dbIdleTime * 100.0 
      / (<span class="KEYWORD">double</span>)sysinfo.NumberProcessors + 0.5;
  }

  <span class="COMMENT">// сохраняем полученные значения</span>
  liOldIdleTime = perfinfo.IdleTime;
  liOldSystemTime = timeinfo.CurrentTime;

  <span class="COMMENT">// Если это первый вызов, получаем загруженность CPU за последние </span>
  <span class="COMMENT">// 200 милисекунд</span>
  <span class="KEYWORD">if</span>(dbIdleTime == 0)
  {
    Sleep(200);
    dbIdleTime = GetCPUUsage();
  }
  
  <span class="KEYWORD">return</span> dbIdleTime;
}

<span class="COMMENT">// Возвращает true, если поток имеет незавершенные операции ввода/вывода</span>
<span class="KEYWORD">bool</span> HasThreadIoPending(HANDLE hThread = GetCurrentThread())
{
  <span class="KEYWORD">typedef</span> NTSTATUS (NTAPI ZwQueryInformationThread_t)(
    IN HANDLE ThreadHandle, 
    IN NT::THREADINFOCLASS ThreadInformationClass, 
    OUT PVOID ThreadInformation, 
    IN ULONG ThreadInformationLength, 
    OUT PULONG ReturnLength OPTIONAL
  );

  <span class="KEYWORD">static</span> ZwQueryInformationThread_t* ZwQueryInformationThread = 0;
  <span class="KEYWORD">if</span>(!ZwQueryInformationThread)
  {
    ZwQueryInformationThread = (ZwQueryInformationThread_t*)GetProcAddress(
      GetModuleHandle(_T(<span class="STRING">"ntdll.dll"</span>)), _T(<span class="STRING">"NtQueryInformationThread"</span>));
  }

  ULONG io = 0;

  ZwQueryInformationThread(hThread, NT::ThreadIsIoPending, &amp;io, 4, 0);

  <span class="KEYWORD">return</span> io &gt; 0;
}

<span class="COMMENT">// Возвращает количество необработанных запросов в очереди порта</span>
DWORD GetIoCompletionLen(HANDLE hIoPort)
{
  <span class="KEYWORD">typedef</span> NTSTATUS (NTAPI ZwQueryIoCompletion_t)(
    IN HANDLE IoCompletionHandle, 
    IN NT::IO_COMPLETION_INFORMATION_CLASS IoCompletionInformationClass,
    OUT PVOID IoCompletionInformation, 
    IN ULONG IoCompletionInformationLength, 
    OUT PULONG ResultLength OPTIONAL
  );

  <span class="KEYWORD">static</span> ZwQueryIoCompletion_t* ZwQueryIoCompletion = 0;
  <span class="KEYWORD">if</span>(!ZwQueryIoCompletion)
  {
    ZwQueryIoCompletion = (ZwQueryIoCompletion_t*)GetProcAddress(
      GetModuleHandle(_T(<span class="STRING">"ntdll.dll"</span>)), _T(<span class="STRING">"NtQueryIoCompletion"</span>));
  }

  NT::IO_COMPLETION_BASIC_INFORMATION ioinfo = {0};
  DWORD dwRetLen = 0;
  ZwQueryIoCompletion(hIoPort, NT::IoCompletionBasicInformation, 
    &amp;ioinfo, <span class="KEYWORD">sizeof</span> ioinfo, &amp;dwRetLen);
  
  <span class="KEYWORD">return</span> ioinfo.SignalState;
}
</pre></td></tr></tbody></table></div>
<p>Как видите, не простое это дело – создавать эффективный пул потоков, 
однако кое-что ребята из Microsoft могут нам предложить. В Windows 2000 
появились новые функции, которые полностью берут на себя всю черновую 
работу по созданию и удалению потоков в пуле. О них – следующий раздел.</p>

<h2>Встроенная поддержка пула потоков<a name="EFJAC"></a></h2>
<p>В Windows 2000 появились новые функции, которые условно можно разделить на четыре группы:</p>
<ul style="LIST-STYLE:square"><li>помещение запроса в очередь; </li>
<li>вызов функции при окончании асинхронной операции ввода/вывода; </li>
<li>периодический вызов функции; </li>
<li>вызов функции при переходе объекта в сигнальное состояние. </li>
</ul>
<p>Рассмотрим их по порядку.</p>
<h3>Помещение запроса в очередь<a name="EWJAC"></a></h3>
<p>Передать на выполнение потоку из пула какую-либо функцию можно с помощью сервиса <b>QueueUserWorkItem</b>.
 Эта с виду простая функция делает очень много: она создает порт 
завершения ввода/вывода, создает и уничтожает потоки в пуле и многое 
другое. Вот ее описание:</p>
<div id="E5JAC"><table class="code" width="98%"><tbody><tr><td><pre>BOOL QueueUserWorkItem(
  LPTHREAD_START_ROUTINE Function,  <span class="COMMENT">// адрес функции</span>
  PVOID Context,                    <span class="COMMENT">// произвольный параметр</span>
  ULONG Flags                       <span class="COMMENT">// флаги выполнения</span>
);
</pre></td></tr></tbody></table></div>
<p>QueueUserWorkItem помещает пакет запроса в виде адреса функции и 
произвольного параметра в очередь запросов порта завершения и сразу же 
возвращает управление. Вот как выглядит функция, которая будет вызвана 
одним из потоков в пуле:</p>
<div id="EJKAC"><table class="code" width="98%"><tbody><tr><td><pre>DWORD WINAPI ThreadProc(
  LPVOID lpParameter   <span class="COMMENT">// произвольный параметр</span>
);
</pre></td></tr></tbody></table></div>
<p>Ее прототип ничем не отличается от стартовой процедуры потока, так 
что здесь вам все должно быть ясно. Гораздо интереснее знать, что 
скрывается внутри функции QueueUserWorkItem. Давайте разбираться.</p>
<p>При первом помещении запроса количество потоков в пуле равно нулю, 
так что QueueUserWorkItem приходится создавать поток и порт завершения. 
Затем в порт помещается пакет запроса, а поток вызывает функцию 
GetQueuedCompletionStatus. После обработки запроса поток не разрушается,
 а остается еще некоторое время в пуле, так что следующий запрос 
обработается намного быстрее. Если вы отправляете запросы слишком часто,
 и количество необработанных пакетов увеличивается, QueueUserWorkItem 
создаст для вызова функции новый поток. Максимальное количество потоков в
 пуле равно количеству процессоров, что не очень хорошо, но есть способ 
заставить функцию всегда создавать новый поток.</p>
<table class="note" width="98%"><tbody><tr><td><strong>ПРИМЕЧАНИЕ</strong><br><p>Те
 из вас, кто читал статью Дж. Рихтера «New Windows 2000 Pooling 
Functions Greatly Simplify Thread Management» из апрельского MSJ за 1999
 год, могут поспорить со мной насчет размера пула. В статье указывается,
 что количество потоков в нем равно удвоенному количеству процессоров в 
системе, однако это не так. Вы можете собственноручно в этом убедиться, 
поставив breakpoint на функцию _RtlpInitializeWorkerThreadPool (адрес 
0x77FA95CD на Windows 2000 Professional SP3) и вызвав функцию 
QueueUserWorkItem.</p>
</td></tr></tbody></table>
<p>Рассмотрим флаги функции QueueUserWorkItem.</p>
<table cellspacing="2" cellpadding="5" border="0"><tbody><tr><th>Константа</th><th>Значение</th><th>Описание</th></tr>
<tr><td>WT_EXECUTEDEFAULT</td><td>0</td><td>Запрос помещается в простой рабочий поток</td></tr>
<tr><td>WT_EXECUTEINIOTHREAD</td><td>1</td><td>Запрос помещается в поток ввода/вывода</td></tr>
<tr><td>WT_EXECUTEINPERSISTENTTHREAD</td><td>0x80</td><td>Запрос 
помещается в поток, который не завершается после обработки запроса, 
поэтому он может сохранять свое состояние, например в TLS.</td></tr>
<tr><td>WT_EXECUTELONGFUNCTION</td><td>0x10</td><td>Запрос с данным флагом всегда помещается в новый поток</td></tr>
</tbody></table><font style="font-size:x-small;margin-left:1em" face="verdana"><i>Таблица 3. Флаги функции QueueUserWorkItem.</i></font>
<p>Если вы не выполняете асинхронных запросов ввода/вывода в функции 
ThreadProc, не используете TLS (Thread Local Storage) или функций, 
которые его используют, а продолжительность выполнения операции невелика
 – указывайте флаг WT_EXECUTEDEFAULT.</p>
<p>Предположим, вы начали асинхронную операцию ввода/вывода в своей 
функции ThreadProc. Для того чтобы она завершилась, поток в котором она 
началась, не должен быть разрушен. Однако флаг WT_EXECUTEDEFAULT этого 
не гарантирует. С этим флагом поток может быть удален, даже если у него 
имеются незавершенные асинхронные операции. Для того чтобы поток 
завершался только после окончания всех начатых асинхронных операций, 
нужно указать флаг WT_EXECUTEINIOTHREAD.</p>
<p>При указании флага WT_EXECUTEINPERSISTENTTHREAD пакет запроса 
помещается в поток, который никогда не удаляется, так что вы спокойно 
можете использовать TLS. Так как поток всего один, не рекомендуется 
выполнять в нем продолжительных операций.</p>
<p>И наоборот, если вам нужно каждый раз выполнять длительную операцию, 
укажите флаг WT_EXECUTELONGFUNCTION. Для каждой такой операции создается
 новый поток, который после ее обработки удаляется.</p>
<table cellspacing="2" cellpadding="5" border="0"><tbody><tr><th>Характеристика</th><th>Значение</th></tr>
<tr><td>Начальное количество потоков в пуле</td><td>0</td></tr>
<tr><td>Когда поток удаляется</td><td>Поток не имеет незавершенных операций ввода/вывода и простаивает некоторое время</td></tr>
<tr><td>Способ ожидания, используемый потоком</td><td>Тревожное (alertable) ожидание</td></tr>
<tr><td>Поток просыпается при</td><td>Приходе APC-запроса</td></tr>
</tbody></table><font style="font-size:x-small;margin-left:1em" face="verdana"><i>Таблица 4. Описание работы функции QueueUserWorkItem</i></font>

<h3>Вызов функции при окончании асинхронной операции ввода/вывода<a name="EUMAC"></a></h3>
<p>Если в программе выполняется большое количество операций 
ввода/вывода, лучше, чтобы они выполнялись асинхронно. Это намного 
повышает производительность приложения и уменьшает время отклика на 
клиентские запросы. Однако самое сложное в асинхронных операциях – 
правильно продолжить или завершить их. Можно связать все устройства 
(файлы) с портом завершения и обрабатывать окончания операций в 
отдельном потоке. Когда операций много, вновь встает вопрос об 
организации пула потоков для обработки асинхронных операций 
ввода/вывода. К счастью, у нас имеется хороший помощник:</p>
<div id="EZMAC"><table class="code" width="98%"><tbody><tr><td><pre>BOOL BindIoCompletionCallback(
  <span class="COMMENT">// хендл файла</span>
  HANDLE FileHandle,                       
  <span class="COMMENT">// функция обработки завершения запроса</span>
  LPOVERLAPPED_COMPLETION_ROUTINE Function, 
  <span class="COMMENT">// зарезервировано</span>
  ULONG Flags                              
);
</pre></td></tr></tbody></table></div>
<p>Эта функция создает порт завершения и связывает его с файлом. Затем 
функция создает поток, который сразу же начинает ждать 
(GetQueuedCompletionStatus) окончания асинхронной операции, после чего 
вызывает определяемую вами функцию для обработки запроса. Вот ее 
прототип:</p>
<div id="EENAC"><table class="code" width="98%"><tbody><tr><td><pre>VOID CALLBACK FileIOCompletionRoutine(
  DWORD dwErrorCode,                <span class="COMMENT">// код завершения</span>
  DWORD dwNumberOfBytesTransfered,  <span class="COMMENT">// количество переданных байтов</span>
  LPOVERLAPPED lpOverlapped         <span class="COMMENT">// структура OVERLAPPED</span>
);
</pre></td></tr></tbody></table></div>
<p>Хотя прототип этой функции идентичен функции, вызываемой при 
окончании операций, начатых ReadFileEx и WriteFileEx, не стоит их 
путать. При использовании BindIoCompletionCallback эта функция 
вызывается с помощью порта завершения ввода/вывода, тогда как при 
использовании ReadFileEx и WriteFileEx функция вызывается с помощью APC.</p>
<p>Совершенно непонятно, почему в Microsoft решили не использовать флаги
 для этой функции, но факт остается фактом. И хотя Рихтер в своей 
статье, которая упоминалась выше, утверждает, что можно указать флаг 
WT_EXECUTEINIOTHREAD, это неправда. Вы можете сами посмотреть 
дизассемблером в ntdll.dll, например, функцию RtlSetIoCompletionCallback
 и убедиться, что третий параметр в ней просто не используется.</p>
<p>Как видно из прототипа, вы не можете передавать какого-либо 
дополнительного параметра функции FileIOCompletionRoutine, что может 
вызвать определенные проблемы. Самым распространенным решением является 
передача в функцию начала асинхронной операции структуры, производной от
 OVERLAPPED. Тогда в дополнительных членах структуры можно передавать 
какую угодно информацию – сама структура OVERLAPPED не копируется, везде
 передается только указатель на нее.</p>
<table cellspacing="2" cellpadding="5" border="0"><tbody><tr><th>Характеристика</th><th>Значение</th></tr>
<tr><td>Начальное количество потоков в пуле</td><td>0</td></tr>
<tr><td>Когда поток удаляется</td><td>Поток простаи-вает некоторое время</td></tr>
<tr><td>Способ ожидания, используемый потоком</td><td>GetQueuedCompletionStatus</td></tr>
<tr><td>Поток просыпается при</td><td>Постановке пакета запроса в очередь порта</td></tr>
</tbody></table><font style="font-size:x-small;margin-left:1em" face="verdana"><i>Таблица 5. Описание характеристик работы функции BindIoCompletionCallback</i></font>

<h3>Периодический вызов функции<a name="ELOAC"></a></h3>
<p>В самом начале статьи я обещал рассказать о новых «таймерных» 
функциях. До выхода Windows 2000 имелось три механизма периодического 
вызова пользовательских функций: «оконный» таймер, Multimedia-таймер и 
ожидающий таймер. У каждого из них были серьезные недостатки, к тому же 
они не поддерживали обработку запросов в пуле. Новые функции по созданию
 очереди таймеров более универсальны.</p>
<p>В Windows 2000 появился новый объект – очередь таймеров. Он основан 
на объекте исполнительной системы "ожидающий таймер", так что в качестве
 механизма обратного вызова используется APC. Создать объект можно с 
помощью следующей функции:</p>
<div id="ESOAC"><table class="code" width="98%"><tbody><tr><td><pre>HANDLE CreateTimerQueue(VOID);
</pre></td></tr></tbody></table></div>
<p>Она возвращает хендл объекта "очередь таймеров" (queues of timers). 
После создания очереди в нее можно добавлять новые таймеры. Для этого 
используется функция CreateTimerQueueTimer:</p>
<div id="EWOAC"><table class="code" width="98%"><tbody><tr><td><pre>BOOL CreateTimerQueueTimer(
  <span class="COMMENT">// указатель на хендл таймера</span>
  PHANDLE phNewTimer,         
  <span class="COMMENT">// хендл очереди таймеров</span>
  HANDLE TimerQueue,          
  <span class="COMMENT">// функция обратного вызова</span>
  WAITORTIMERCALLBACK Callback,
  <span class="COMMENT">// параметр для функции обратного вызова</span>
  PVOID Parameter,            
  <span class="COMMENT">// время задержки перед первым вызовом в милисекундах</span>
  DWORD DueTime,              
  <span class="COMMENT">// период в милисекундах</span>
  DWORD Period,               
  <span class="COMMENT">// флаги</span>
  ULONG Flags                 
);
</pre></td></tr></tbody></table></div>
<p>Рассмотрим параметры этой функции. Первый параметр возвращает хендл 
таймера, который можно использовать для вызова функций изменения таймера
 или его удаления (о них позже). Второй параметр – хендл очереди, 
созданной функцией CreateTimerQueue. В качестве него можно указать 
нулевое значение. В этом случае по умолчанию таймер будет добавлен к 
объекту "очередь таймеров". Третий параметр – адрес функции, которая 
будет вызвана при переходе таймера в сигнальное состояние. Вот ее 
прототип:</p>
<div id="EJPAC"><table class="code" width="98%"><tbody><tr><td><pre>VOID CALLBACK WaitOrTimerCallback(
  PVOID lpParameter,        <span class="COMMENT">// произвольный параметр</span>
  BOOLEAN TimerOrWaitFired  <span class="COMMENT">// причина вызова</span>
);
</pre></td></tr></tbody></table></div>
<p>Произвольный параметр для нее указывается в функции 
CreateTimerQueueTimer четвертым параметром. Параметр TimerOrWaitFired 
для таймеров всегда равен TRUE. </p>
<p>Пятый параметр определяет, сколько времени в миллисекундах пройдет до
 первого вызова функции WaitOrTimerCallback. Если указать 0, то эта 
функция будет вызвана практически сразу (примерно так же быстро, как и в
 случае QueueUserWorkItem). </p>
<p>Шестой параметр задает период вызова пользовательской функции. В 
качестве этого параметра можно указать нулевое значение, тогда функция 
WaitOrTimerCallback будет вызвана только один раз.</p>
<p>В качестве флагов функции CreateTimerQueueTimer можно указывать все флаги из таблицы 2 и два новых:</p>
<table cellspacing="2" cellpadding="5" border="0"><tbody><tr><th>Константа</th><th>Значение</th><th>Описание</th></tr>
<tr><td>WT_EXECUTEINTIMERTHREAD</td><td>0x20</td><td>Пользовательская функция вызывается в потоке таймера</td></tr>
<tr><td>WT_EXECUTEONLYONCE</td><td>8</td><td>Пользовательская функция вызывается только один раз</td></tr>
</tbody></table><font style="font-size:x-small;margin-left:1em" face="verdana"><i>Таблица 6. Флаги функции CreateTimerQueueTimer.</i></font>
<p>Если ваша функция WaitOrTimerCallback очень быстро отрабатывает, а 
количество запросов невелико – лучше всего указать флаг 
WT_EXECUTEINTIMERTHREAD. В этой ситуации функция будет вызвана в потоке,
 ожидающем таймера. Будьте осторожны – длительная блокировка 
пользовательской функции приведет к тому, что ожидающий поток не сможет 
обрабатывать приходящие запросы.</p>
<p>При указании флага WT_EXECUTEONLYONCE таймер будет установлен в сигнальное состояние только один раз.</p>
<p>Если вам больше не нужен таймер, его можно удалить из очереди с помощью функции DeleteTimerQueueTimer.</p>
<div id="ERAAE"><table class="code" width="98%"><tbody><tr><td><pre>BOOL DeleteTimerQueueTimer(
  <span class="COMMENT">// хендл очереди таймеров</span>
  HANDLE TimerQueue,    
  <span class="COMMENT">// хендл таймера</span>
  HANDLE Timer,
  <span class="COMMENT">// хендл объекта, устанавливаемого в сигнальное состояние после удаления</span>
  HANDLE CompletionEvent
);
</pre></td></tr></tbody></table></div>
<p>Если используется очередь по умолчанию, в качестве первого параметра 
нужно передать NULL. Второй параметр – хендл удаляемого таймера. Третий 
параметр может принимать следующие значения:</p>
<ul style="LIST-STYLE:square"><li>INVALID_HANDLE_VALUE – означает, что 
вызывающая функция будет заблокирована до тех пор, пока таймер не 
обработает все текущие запросы. Вы должны быть осторожны с этим 
значением, так как вызов функции удаления таймера в самой 
пользовательской функции приведет к взаимоблокировке (deadlock). </li>
<li>NULL – если вы не хотите ожидать завершения обработки всех текущих 
запросов. Функция DeleteTimerQueueTimer возвратит управление немедленно.
 </li>
<li>Допустимый хендл объекта – если необходимо синхронизировать 
окончание обработки текущих запросов. Функция DeleteTimerQueueTimer 
возвратит управление немедленно, но после окончания обработки запросов 
объект завершения устанавливается в сигнальное состояние. </li>
</ul>
<p>Можно сразу удалить всю очередь таймеров с помощью следующей функции:</p>
<div id="EGBAE"><table class="code" width="98%"><tbody><tr><td><pre>BOOL DeleteTimerQueueEx(
  <span class="COMMENT">// хендл очереди таймеров</span>
  HANDLE TimerQueue,    
  <span class="COMMENT">// хендл объекта, устанавливаемого в сигнальное состояние после удаления</span>
  HANDLE CompletionEvent
);
</pre></td></tr></tbody></table></div>
<p>Если удаляется очередь по умолчанию, в качестве первого параметра 
нужно передать NULL. Второй параметр имеет то же значение, что и в 
предыдущей функции DeleteTimerQueueTimer.</p>
<p>Кроме создания и удаления таймера в очереди, можно изменять некоторые
 его характеристики. Это делается вызовом функции ChangeTimerQueueTimer.</p>
<div id="ERBAE"><table class="code" width="98%"><tbody><tr><td><pre>BOOL ChangeTimerQueueTimer(
  HANDLE TimerQueue,  <span class="COMMENT">// хендл очереди таймеров</span>
  HANDLE Timer,       <span class="COMMENT">// хендл таймера</span>
  ULONG DueTime,      <span class="COMMENT">// новое значение задержки перед вызовом</span>
  ULONG Period        <span class="COMMENT">// новое значение периода вызова</span>
);
</pre></td></tr></tbody></table></div>
<p>Функция вопросов не вызывает, однако нужно отметить, что она не 
оказывает влияния на «одноразовые» (one-shot) таймеры, при создании 
которых в качестве периода был указан 0.</p>
<table cellspacing="2" cellpadding="5" border="0"><tbody><tr><th>Характеристика</th><th>Значение</th></tr>
<tr><td>Начальное количество потоков в пуле</td><td>1</td></tr>
<tr><td>Когда поток удаляется</td><td>Когда удаляется последний таймер из очереди</td></tr>
<tr><td>Способ ожидания, используемый потоком</td><td>Тревожное (alertable) ожидание</td></tr>
<tr><td>Поток просыпается при</td><td>Приходе APC-запроса</td></tr>
</tbody></table><font style="font-size:x-small;margin-left:1em" face="verdana"><i>Таблица 7. Описание характеристик работы объекта "очередь таймеров".</i></font>

<h3>Вызов функции при переходе объекта в сигнальное состояние<a name="EWCAE"></a></h3>
<p>В приложении часто возникает необходимость дождаться какого-либо 
объекта и выполнить определенное действие. Для многопоточных приложений 
приходится для каждого такого случая заводить отдельный поток, что 
нехорошо. В этом случае на помощь приходит функция 
RegisterWaitForSingleObject. Она позволяет вызывать произвольную 
пользовательскую функцию после того, как заданный объект перейдет в 
сигнальное состояние. Причем никаких потоков создавать не нужно, все 
делается автоматически. Рассмотрим прототип этой функции:</p>
<div id="E2CAE"><table class="code" width="98%"><tbody><tr><td><pre>BOOL RegisterWaitForSingleObject( 
  PHANDLE phNewWaitObject,       <span class="COMMENT">// адрес хендла объекта ожидания</span>
  HANDLE hObject,                <span class="COMMENT">// хендл объекта</span>
  WAITORTIMERCALLBACK Callback,  <span class="COMMENT">// функция обратного вызова</span>
  PVOID Context                  <span class="COMMENT">// произвольный параметр</span>
  ULONG dwMilliseconds,          <span class="COMMENT">// таймаут</span>
  ULONG dwFlags                  <span class="COMMENT">// флаги</span>
);
</pre></td></tr></tbody></table></div>
<p>Первый параметр – это указатель на переменную, в которую будет 
возвращен хендл объекта ожидания. Нужно отметить, что на самом деле это 
не хендл объекта и его нельзя использовать, например, с функцией 
CloseHandle. Этот хендл можно использовать только для передачи функции 
UnregisterWait или UnregisterWaitEx (о них поговорим попозже). В 
качестве второго параметра нужно передать хендл объекта, перехода 
которого в сигнальное состояние ожидает эта функция. Третий параметр – 
адрес функции WaitOrTimerCallback, которую мы описывали раньше. 
Четвертый параметр – это любое значение, которое просто передается 
функции WaitOrTimerCallback. В качестве пятого параметра можно указать 
количество миллисекунд, которое определяет максимальное время ожидания 
объекта. После его истечения функция WaitOrTimerCallback будет вызвана 
со вторым параметром, равным TRUE. Если объект перешел в сигнальное 
состояние до истечения кванта времени, второй параметр функции 
WaitOrTimerCallback будет равным FASLE.</p>
<p>В качестве флагов можно указывать все описанные ранее значения и одно
 новое – WT_EXECUTEINWAITTHREAD. Его можно использовать, только если вы 
выполняете очень короткие операции, функция WaitOrTimerCallback будет 
вызвана в самом ожидающем потоке. Любая задержка в пользовательской 
функции приведет к тому, что поток не сможет обработать переход в 
сигнальное состояние объекта вовремя. Замечу, что при ожидании 
сигнального состояния события с ручным сбросом (manual reset event) не 
следует вызывать функцию PulseEvent, если не указаны флаги 
WT_EXECUTEINWAITTHREAD или WT_EXECUTEONLYONCE, так как в этом случае 
ожидающий поток не сможет обработать событие перехода объекта в 
сигнальное состояние.</p>
<p>Для остановки вызова пользовательской функции можно воспользоваться следующими функциями:</p>
<div id="EQDAE"><table class="code" width="98%"><tbody><tr><td><pre>BOOL UnregisterWait(
  <span class="COMMENT">// хендл ожидания</span>
  HANDLE WaitHandle    
);

BOOL UnregisterWaitEx(
  <span class="COMMENT">// хендл ожидания</span>
  HANDLE WaitHandle,    
  <span class="COMMENT">// хендл объекта, устанавливаемого в сигнальное состояние после удаления</span>
  HANDLE CompletionEvent 
);
</pre></td></tr></tbody></table></div>
<table cellspacing="2" cellpadding="5" border="0"><tbody><tr><th>Характеристика</th><th>Значение</th></tr>
<tr><td>Начальное количество потоков в пуле</td><td>1</td></tr>
<tr><td>Когда поток удаляется</td><td>Когда количество объектов равно нулю</td></tr>
<tr><td>Способ ожидания, используемый потоком</td><td>WaitForMultipleObjectsEx</td></tr>
<tr><td>Поток просыпается при</td><td>Переходе объекта ядра в сигнальное состояние</td></tr>
</tbody></table><font style="font-size:x-small;margin-left:1em" face="verdana"><i>Таблица 8. Описание работы функции RegisterWaitForSingleObject</i></font>

<h2>Заключение<a name="ESEAE"></a></h2>
<p>Написание многопоточных серверных приложений – одна из самых сложных 
областей программирования. Как правило, для этого необходимо детально 
знать механизмы ОС, подсистему безопасности и функционирование служб (в 
большинстве случаев серверные приложения являются службами). В 
дальнейшем я, возможно, постараюсь осветить другие аспекты данной 
области. Надеюсь, этот материал был вам интересен.</p>
<h2>Литература<a name="EYEAE"></a></h2>
<ol><li>Программирование серверных приложений для Windows 2000, Дж. Рихтер, Дж. Кларк.</li>
<li>Недокументированные возможности Windows NT, Коберниченко А.В.</li>
<li>NativeAPI, Гарри Неббет</li>
<li>Внутреннее устройство Windows 2000, Д. Соломон, М. Руссинович.</li>
<li>Недокументированные возможности Windows 2000. С. Шрайбер.</li>
</ol>
<p></p>
<div align="right"><font style="font-family:arial;font-size:9pt;color:#8088a0"><i><hr width="100%" size="1" color="#8088a0"><div align="justify"><font size="2">
                     Эта статья опубликована в журнале 
                     RSDN Magazine
                                         
                        #2-2003. Информацию о журнале можно найти <a href="https://www.rsdn.org/mag/main.htm">здесь</a></font></div></i></font></div>	<script>
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

	ga('create', 'UA-1276305-1', 'auto');
	ga('send', 'pageview');
	</script>
<table celpadding="2" style="font-family:verdana;font-weight:bold;padding: 0px 5px; BORDER: #9daabd 1px 	solid; 	COLOR: #646464; BACKGROUND-COLOR: #e6e6e6;" width="100%" cellspacing="0" border="0"><tbody><tr><td nowrap="nowrap"><font style="font-weight:normal" size="1"><script src="%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_files/shMenu.js" type="text/javascript" charset="utf-8"></script>&lt;&lt;<a href="https://www.rsdn.org/?article/baseserv/threadpool.xml" target="_top">Показать&nbsp;меню</a>&nbsp;</font></td><td width="100%" nowrap="nowrap" align="right"><font size="2">&nbsp;<a href="https://www.rsdn.org/article/baseserv/threadpool.xml?print" target="_blank" title="Версия для печати"><img src="%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_files/printer2.gif" width="16" height="14" border="0" align="absmiddle"></a>&nbsp;&nbsp;<a href="https://www.rsdn.org/forum/winapi/350009" target="_self" title="Перейти к обсуждению статьи"><font size="1" color="#646464"> Сообщений </font><font color="black">4</font></a>&nbsp;&nbsp;<a href="https://www.rsdn.org/forum/winapi/350009" target="_self" title="Перейти к обсуждению статьи"><img src="%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_files/showfr.gif" width="18px" height="14px" border="0" align="absmiddle"></a>&nbsp;<a href="https://www.rsdn.org/Forum/RateList.aspx?mid=350009"><font color="#646464"><font size="1"> Оценка </font><font color="black">1071</font>
									[<font style="font-weight: normal;"><span style="color:green;">+1</span>/<span style="color:blue;">-0</span></font>]
								</font></a>&nbsp;&nbsp; <a target="_blank" rel="nofollow" href="https://www.rsdn.org/Users/Private/AddFav.aspx?mid=350009" onclick="return AddFav(this.href);" title="Добавить в избранное"><img src="%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_files/fav.gif" height="14px" border="0" align="absmiddle"></a>&nbsp;&nbsp;<a href="https://www.rsdn.org/Forum/Private/Subscr.aspx?tid=350009" onclick="return SubMsg(this.href)" title="Подписка на сообщения" rel="nofollow"><img class="i" src="%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_files/sub.gif" width="18px" height="14px" border="0" align="absmiddle"></a>&nbsp;&nbsp;&nbsp;<font size="1">Оценить </font><a target="_blank" rel="nofollow" href="https://www.rsdn.org/forum/Private/Rate.aspx?mid=350009&amp;rate=-3" onclick="return RateMsg(this.href);" title="+1"><img src="%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_files/n11.gif" width="18px" height="14px" border="0" align="absmiddle"></a><a target="_blank" rel="nofollow" href="https://www.rsdn.org/forum/Private/Rate.aspx?mid=350009&amp;rate=1" onclick="return RateMsg(this.href);" title="Интересно"><img src="%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_files/n1.gif" width="18px" height="14px" border="0" align="absmiddle"></a><a target="_blank" rel="nofollow" href="https://www.rsdn.org/forum/Private/Rate.aspx?mid=350009&amp;rate=2" onclick="return RateMsg(this.href);" title="Спасибо"><img src="%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_files/n2.gif" width="18px" height="14px" border="0" align="absmiddle"></a><a target="_blank" rel="nofollow" href="https://www.rsdn.org/forum/Private/Rate.aspx?mid=350009&amp;rate=3" onclick="return RateMsg(this.href);" title="Супер"><img src="%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_files/n3.gif" width="18px" height="14px" border="0" align="absmiddle"></a><a target="_blank" rel="nofollow" href="https://www.rsdn.org/forum/Private/Rate.aspx?mid=350009&amp;rate=-1" onclick="return RateMsg(this.href);" title="Удалить оценку"><img src="%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_files/nx.gif" width="18px" height="14px" border="0" align="absmiddle"></a><a target="_blank" rel="nofollow" href="https://www.rsdn.org/forum/Private/Rate.aspx?mid=350009&amp;rate=-4" onclick="return RateMsg(this.href);" title="Согласен"><img src="%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_files/np.gif" width="18px" height="14px" border="0" align="absmiddle"></a><a target="_blank" rel="nofollow" href="https://www.rsdn.org/forum/Private/Rate.aspx?mid=350009&amp;rate=0" onclick="return RateMsg(this.href);" title="Не согласен"><img src="%D0%AD%D1%84%D1%84%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C_files/nm.gif" eight="14px" width="18px" border="0" align="absmiddle"></a>&nbsp;
					</font></td></tr></tbody></table></body></html>